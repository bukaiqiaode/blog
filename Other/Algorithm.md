# Bitmap, Hashmap, Bloom-Filter, 堆，桶，外部排序，Map-Reduce， 树

# 有5亿个整数，没有排序。找到他们的中位数
## 思路
使用双层桶划分(分而治之)的策略。假设题目中指的是32位的无符号整数，共有2 ^ 32个数字。<br />
我们将2 ^ 32这个范围划分成2 ^ 10个区域。对数据进行第一次扫描，统计各个落到各个区域内的数字的个数。<br />
第一次扫描后，通过统计就可以知道，中位数在哪个区域内，以及它是这个区域的第几大的数字。<br />
进行第二次扫描，这次只统计落到目标区域内的数字，同时结合Bitmap记录都出现了哪些数字。最后通过Bitmap和第一次扫描的结论，就可以找到那个中位数了。

# 给40亿个不重复的unsigned int，没有排序。然后给定一个数，如何判断这个数是否在40亿个里面？
## 分析
unsigned int，就算他是32位的吧，2 ^ 32 = 4 G个数字。使用Bitmap的话，一个字节Byte有8位可以用来控制8个数字。4 GB / 8 = 1 GB / 2 = 512 MB，需要占用的内存还算可接受，因此我们可以使用Bitmap来解决这个问题。

## 思路
用512 MB的内存，建立一个Bitmap数组。扫描那40亿个数，如果某个数字出现，就将Bitmap数组的对应位置赋值1。这样通过一轮扫描，就保存了40亿整数里面都有哪些数。
对于某个给定的数，检查Bitmap对应的位置，就知道这个数字是否在40亿个数字中出现过了。

# Back to [index](./index.md)
